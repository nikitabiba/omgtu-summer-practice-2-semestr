#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System.Threading;
using System.Diagnostics;
using System.Reflection;

class DefiniteIntegral
{
    static Barrier barrier;
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        barrier = new Barrier(threadsnumber);
        double square = 0.0;
        double lengthForThread = Math.Abs(b-a) / (double)threadsnumber;
        List<Thread> threads = new List<Thread>();
        for(int i = 0; i < threadsnumber; i++)
        {
            double start = a + (double)(i) * lengthForThread;
            double end = start + lengthForThread;
            threads.Add(new Thread(() => OneThreadSquare(ref square, start, end, function, step)));
        }
        foreach(Thread thread in threads) thread.Start();
        foreach(Thread thread in threads) thread.Join();
        return square;
    }
    public static void OneThreadSquare(ref double square, double start, double end, Func<double, double> function, double step)
    {
        double threadsquare = 0.0;
        double x1 = start;
        double x2 = start + step;
        for(int j = 0; j < Math.Truncate(Math.Abs(end-start) / step); j++)
        {
            threadsquare += ((function(x1) + function(x2)) / 2) * step;
            x1 += step;
            x2 += step;
        }
        if (x2 > end) threadsquare += ((function(x1) + function(end)) / 2) * (end - x1);
        Interlocked.CompareExchange(ref square, square + threadsquare, square);
        barrier.SignalAndWait();
    }
}

class TrapezoidalRule
{
    public static double Solve(Func<double, double> f, double a, double b, double dx){
        double square = 0;
        double x1 = a;
        double x2 = a + dx;
        if (x2 <= a + Double.Epsilon) throw new ArgumentException("Too small value");
        for(int i = 0; i < Math.Truncate(Math.Abs(b-a) / dx); i++)
        {
            square += ((f(x1) + f(x2)) / 2) * dx;
            x1 += dx;
            x2 += dx;
        }
        if (x2 > b) square += ((f(x1) + f(b)) / 2) * (b - x1);
        return square;
    }
}

public static void TimeCounter(string solveFunc, string step, int numthreads = 1)
{
    var SIN = (double x) => Math.Sin(x);
    List<int> runtimes = new List<int>();
    double dx = Convert.ToDouble(step);
    double result = 0.0;
    if (solveFunc == nameof(TrapezoidalRule)) for(int i = 0; i < 20; i++)
    {
        Stopwatch stopWatch = new Stopwatch();
        stopWatch.Start();
        result = TrapezoidalRule.Solve(SIN, -100, 100, dx);
        stopWatch.Stop();
        runtimes.Add(stopWatch.Elapsed.Milliseconds);
    }
    else if (solveFunc == nameof(DefiniteIntegral)) for(int i = 0; i < 20; i++)
    {
        Stopwatch stopWatch = new Stopwatch();
        stopWatch.Start();
        result = DefiniteIntegral.Solve(-100, 100, SIN, dx, numthreads);
        stopWatch.Stop();
        runtimes.Add(stopWatch.Elapsed.Milliseconds);
    }
    var averageRuntime = (from t in runtimes select t).Average();
    Console.WriteLine($"Число потоков: {numthreads}; Шаг: {step}; Результат: {result}; Время: {averageRuntime}");
}

public static double ForListTimeCounter(string solveFunc, string step, int numthreads = 1)
{
    var SIN = (double x) => Math.Sin(x);
    List<int> runtimes = new List<int>();
    double dx = Convert.ToDouble(step);
    double result = 0.0;
    if (solveFunc == nameof(TrapezoidalRule)) for(int i = 0; i < 20; i++)
    {
        Stopwatch stopWatch = new Stopwatch();
        stopWatch.Start();
        result = TrapezoidalRule.Solve(SIN, -100, 100, dx);
        stopWatch.Stop();
        runtimes.Add(stopWatch.Elapsed.Milliseconds);
    }
    else if (solveFunc == nameof(DefiniteIntegral)) for(int i = 0; i < 20; i++)
    {
        Stopwatch stopWatch = new Stopwatch();
        stopWatch.Start();
        result = DefiniteIntegral.Solve(-100, 100, SIN, dx, numthreads);
        stopWatch.Stop();
        runtimes.Add(stopWatch.Elapsed.Milliseconds);
    }
    return (from t in runtimes select t).Average();
}

#!csharp

// Соотношение величины шага и точности вычислений
for(int i = 1; i < 7; i++) TimeCounter("DefiniteIntegral", $"1e-{i}", 24);
// таким образом оптимальным по точности шагом является 1e-4 с точностью приблизительно 1e-14

#!csharp

// Соотношение времени выполнения и числа потоков
#r "nuget:ScottPlot, 5.0.35"

using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);

List<double> runtimesForThreads = new List<double>();
List<int> numberThreads = new List<int>();
for(int i = 2; i < 120; i+=15) 
{
  runtimesForThreads.Add(ForListTimeCounter("DefiniteIntegral", $"1e-4", i));
  numberThreads.Add(i);
}

ScottPlot.Plot plt = new();
plt.Add.Scatter(runtimesForThreads, numberThreads);
plt
// по графику видно, что оптимальным числом потоков будет 48

#!csharp

// Сравнение времени работы многопоточного метода и однопоточного
Console.Write($"Однопоточный: ");
TimeCounter("TrapezoidalRule", $"1e-4");
Console.Write($"Многопоточный: ");
TimeCounter("DefiniteIntegral", $"1e-4", 48);
// таким образом многопоточный метод быстрее однопоточного в 3,5 раза

#!markdown

Summary
1) Оптимальный размер шага: 1e-4
2) Оптимальное число потоков: 48
3) Сравнение скоростей работы многопоточного и однопоточного методов:
   1) В секундах: 15 на 50 соответственно
   2) В процентах: многопоточный быстрее однопоточного на 250%

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);
